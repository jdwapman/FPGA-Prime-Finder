//Tests primality of 64-bit numbers

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module lab7(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output reg		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);


//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [63:0]  value;


wire rst, sample, start;
wire [1:0] debug;
wire [3:0] is_prime, done;
wire [7:0] write_data, read_data;
wire write_enable;
wire [2:0] write_addr, read_addr;
wire c0_sig, c1_sig, clk;

//PLL
pll	pll_inst (
	.inclk0 ( MAX10_CLK1_50 ),
	.c0 ( clk ),
	.c1 ( c1_sig )
	);

//assign clk = MAX10_CLK1_50;
	
//Synchronizers for inputs
synchronizer s1(.clk(clk), .in(SW[9]), .out(rst));
synchronizer s2(.clk(clk), .in(KEY[0]), .out(sample));
synchronizer s3(.clk(clk), .in(KEY[1]), .out(start));
synchronizer s4(.clk(clk), .in(SW[1]), .out(debug[1]));
synchronizer s5(.clk(clk), .in(SW[0]), .out(debug[0]));
synchronizer s6(.clk(clk), .in(SW[3]), .out(read_addr[1]));
synchronizer s7(.clk(clk), .in(SW[2]), .out(read_addr[0]));
synchronizer s8(.clk(clk), .in(SW[4]), .out(read_addr[2]));

//Number generator
number_generator gen(.clk(clk), .rst(rst), .sample(sample), .debug(debug), .value(value));

//Prime Testers
prime_tester prime0(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[0]), .is_prime(is_prime[0]), .count(count), .start_val(64'd2), .end_val((value >> 3))); //Divide by 8, check first eigth
prime_tester prime1(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[1]), .is_prime(is_prime[1]), .count(count), .start_val((value >> 3)), .end_val((value >> 3) * 2'd2));
prime_tester prime2(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[2]), .is_prime(is_prime[2]), .count(count), .start_val((value >> 3) * 2'd2), .end_val((value >> 3) * 2'd3));
prime_tester prime3(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[3]), .is_prime(is_prime[3]), .count(count), .start_val((value >> 3) * 2'd3), .end_val((value >> 1) + 1'b1)); //Check up to half + 1


//Prime Testers
/*
prime_tester prime0(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[0]), .is_prime(is_prime[0]), .count(count), .start_val(64'd2), .end_val((value >> 4))); //Divide by 16, check first half
prime_tester prime1(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[1]), .is_prime(is_prime[1]), .count(count), .start_val((value >> 4)), .end_val((value >> 4) * 2'd2)); //Divide by 16, check first half
prime_tester prime2(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[2]), .is_prime(is_prime[2]), .count(count), .start_val((value >> 4) * 2'd2), .end_val((value >> 4) * 2'd3)); //Divide by 16, check first half
prime_tester prime3(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[3]), .is_prime(is_prime[3]), .count(count), .start_val((value >> 4) * 2'd3), .end_val((value >> 4) * 3'd4)); //Divide by 16, check first half
prime_tester prime4(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[4]), .is_prime(is_prime[4]), .count(count), .start_val((value >> 4) * 3'd4), .end_val((value >> 4) * 3'd5)); //Divide by 16, check first half
prime_tester prime5(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[5]), .is_prime(is_prime[5]), .count(count), .start_val((value >> 4) * 3'd5), .end_val((value >> 4) * 3'd6)); //Divide by 16, check first half
prime_tester prime6(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[6]), .is_prime(is_prime[6]), .count(count), .start_val((value >> 4) * 3'd6), .end_val((value >> 4) * 3'd7)); //Divide by 16, check first half
prime_tester prime7(.clk(clk), .rst(rst), .dividend(value), .start(start), .done(done[7]), .is_prime(is_prime[7]), .count(count), .start_val((value >> 4) * 3'd7), .end_val((value >> 3) + 1'b1)); //Divide by 16, check first half
*/

//Serializer
serializer ser1(.clk(clk), .rst(rst), .save(&done), .data_in(value), .write_data(write_data), .write_enable(write_enable), .write_addr(write_addr));

//RAM
output_ram ram1(.clk(clk), .write_data(write_data), .write_enable(write_enable), .write_addr(write_addr), .read_addr(read_addr), .read_data(read_data));

//Byte to SEG7
byte2_7seg(.in(read_data), .hex0out(HEX0), .hex1out(HEX1));

//Update output lights
always @(*) begin
	LEDR[9:2] = done;

	if (done == 4'b1111) begin
		LEDR[1] = 1'b1;
		
		LEDR[0] = &is_prime;
		
	end
	else begin
		LEDR[1] = 1'b0;
		LEDR[0] = 1'b0;
	end
	
	
end


assign HEX2 = 8'b11111111;
assign HEX3 = 8'b11111111;
assign HEX4 = 8'b11111111;
assign HEX5 = 8'b11111111;

endmodule

//Byte to 7 seg
module byte2_7seg(in, hex0out, hex1out);
	input [7:0] in;
	output [7:0] hex0out, hex1out;
	
	hex_2_7_seg m1(.in(in[7:4]), .out(hex1out));
	hex_2_7_seg m2(.in(in[3:0]), .out(hex0out));
	
endmodule

//hex27_seg
module hex_2_7_seg(in, out);
	input [3:0] in;
	output reg [7:0] out;
	
	parameter ZERO =  8'b1100_0000;
	parameter ONE =   8'b1111_1001;
	parameter TWO = 8'b1010_0100;
	parameter THREE = 8'b1011_0000;
	parameter FOUR = 8'b1001_1001;
	parameter FIVE = 8'b1001_0010;
	parameter SIX = 8'b1000_0010;
	parameter SEVEN = 8'b1111_1000;
	parameter EIGHT = 8'b1000_0000;
	parameter NINE = 8'b1001_1000;
	parameter A = 8'b1000_1000;
	parameter B = 8'b1000_0011;
	parameter C = 8'b1100_0110;
	parameter D = 8'b1010_0001;
	parameter E = 8'b1000_0110;
	parameter F = 8'b1000_1110;
	
	always @(*) begin
		case (in)
			0: out = ZERO;
			1: out = ONE;
			2: out = TWO;
			3: out = THREE;
			4: out = FOUR;
			5: out = FIVE;
			6: out = SIX;
			7: out = SEVEN;
			8: out = EIGHT;
			9: out = NINE;
			10: out = A;
			11: out = B;
			12: out = C;
			13: out = D;
			14: out = E;
			15: out = F;
		endcase
	end

endmodule

//RAM
module output_ram(clk, write_data, write_enable, write_addr, read_addr, read_data);
	input [7:0] write_data;
	input write_enable, clk;
	input [2:0] write_addr;
	input [2:0] read_addr;
	output [7:0] read_data;
	
	reg [7:0] Mem [0:7]; //8 addresses, 8 bits

	//Write
	always @(posedge clk) begin
		if (write_enable == 1'b1) begin
			Mem[write_addr] <= #1 write_data;
		end
	end
	
	assign read_data = Mem[read_addr]; //Read
	
endmodule

//Serializer. Writes data to the RAM
module serializer(clk, rst, save, data_in, write_data, write_enable, write_addr);
	input save, clk, rst;
	input [63:0] data_in;
	output reg [7:0] write_data;
	output reg write_enable;
	output reg [2:0] write_addr;
	wire rising_transition;
	
	//Parameters
	parameter WAIT = 4'b0000;
	parameter ADDR1 = 4'b0001;
	parameter ADDR2 = 4'b0010;
	parameter ADDR3 = 4'b0011;
	parameter ADDR4 = 4'b0100;
	parameter ADDR5 = 4'b0101;
	parameter ADDR6 = 4'b0110;
	parameter ADDR7 = 4'b0111;
	parameter ADDR8 = 4'b1000;
	
	reg [3:0] state, state_c;
	
	edge_detector_rising test(.clk(clk), .input_signal(save), .rising_transition(rising_transition));
	
	always @(*) begin
		state_c = state;
		
		//Write data
		case (state)
			WAIT: begin
				write_enable = 1'b0;
				if (rising_transition == 1'b1) begin //If save changes to high
					state_c = ADDR1;
				end
			end
			ADDR1: begin
				write_enable = 1'b1;
				write_addr = 3'b000;
				write_data = data_in[7:0];
				state_c = ADDR2;
			end
			ADDR2: begin
				write_enable = 1'b1;
				write_addr = 3'b001;
				write_data = data_in[15:8];
				state_c = ADDR3;
			end
			ADDR3: begin
				write_enable = 1'b1;
				write_addr = 3'b010;
				write_data = data_in[23:16];
				state_c = ADDR4;
			end
			ADDR4: begin
				write_enable = 1'b1;
				write_addr = 3'b011;
				write_data = data_in[31:24];
				state_c = ADDR5;
			end
			ADDR5: begin
				write_enable = 1'b1;
				write_addr = 3'b100;
				write_data = data_in[39:32];
				state_c = ADDR6;
			end
			ADDR6: begin
				write_enable = 1'b1;
				write_addr = 3'b101;
				write_data = data_in[47:40];
				state_c = ADDR7;
			end
			ADDR7: begin
				write_enable = 1'b1;
				write_addr = 3'b110;
				write_data = data_in[55:48];
				state_c = ADDR8;
			end
			ADDR8: begin
				write_enable = 1'b1;
				write_addr = 3'b111;
				write_data = data_in[63:56];
				state_c = WAIT;
			end
		endcase
		
		if (rst == 1'b1) begin
			state_c = WAIT;
		end
	end
	
	//FFs
	always @(posedge clk) begin
		state <= #1 state_c;
	end
endmodule

//Synchronizer
module synchronizer(clk, in, out);
	
	input clk, in;
	output reg out;
	reg ff1, ff1_c, ff2, ff2_c, ff3, ff3_c;
	
	always @(*) begin
		ff1_c = in;
		ff2_c = ff1;
		ff3_c = ff2;
		out = ff3;
	end
	
	always @(posedge clk) begin
		ff1 <= #1 ff1_c;
		ff2 <= #1 ff2_c;
		ff3 <= #1 ff3_c;
		
	end
	
endmodule

//Determines whether a number is a prime number
module prime_tester(clk, rst, dividend, start, done, is_prime, count, start_val, end_val, rem0);


	//Inputs
	input [63:0] dividend;
	input start, clk, rst;
	input [63:0] start_val, end_val; //To make modular, multiple prime checkers
	//Outputs
	output reg done, is_prime;
	reg done_c, is_prime_c;
	
	//Counter
	output reg [64:0] count;
	reg [64:0] count_c;
	
	wire [64:0] endValConcat = {1'b0, end_val};
	wire [64:0] startValConcat = {1'b0, start_val};
	
	//Run conditions
	wire falling_transition;
	reg run, run_c;
	reg clear; //Used to reset remainder checker
	
	//Instantiate falling edge module
	edge_detector_falling edge_detector_falling2(.clk(clk), .input_signal(start), .falling_transition(falling_transition));
	
	//Instantiate remainder testing module
	//output [23:0] remainder_done;
	wire [23:0] remainder_done;
	wire [63:0] rem;
	reg [63:0] remainder;
	wire [63:0] remainder_c;
	output [23:0] rem0;
	
	//Remainder testers. Check every other number to only check the odds
	remainder_test test0(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0]), .done(remainder_done[0]), .rem0(rem0[0]));
	remainder_test test1(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd2), .done(remainder_done[1]), .rem0(rem0[1]));
	remainder_test test2(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd4), .done(remainder_done[2]), .rem0(rem0[2]));
	remainder_test test3(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd6), .done(remainder_done[3]), .rem0(rem0[3]));
	remainder_test test4(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd8), .done(remainder_done[4]), .rem0(rem0[4]));
	remainder_test test5(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd10), .done(remainder_done[5]), .rem0(rem0[5]));
	remainder_test test6(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd12), .done(remainder_done[6]), .rem0(rem0[6]));
	remainder_test test7(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd14), .done(remainder_done[7]), .rem0(rem0[7]));
	remainder_test test8(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd16), .done(remainder_done[8]), .rem0(rem0[8]));
	remainder_test test9(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd18), .done(remainder_done[9]), .rem0(rem0[9]));
	remainder_test test10(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd20), .done(remainder_done[10]), .rem0(rem0[10]));
	remainder_test test11(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd22), .done(remainder_done[11]), .rem0(rem0[11]));
	remainder_test test12(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd24), .done(remainder_done[12]), .rem0(rem0[12]));
	remainder_test test13(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd26), .done(remainder_done[13]), .rem0(rem0[13]));
	remainder_test test14(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd28), .done(remainder_done[14]), .rem0(rem0[14]));
	remainder_test test15(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd30), .done(remainder_done[15]), .rem0(rem0[15]));
	remainder_test test16(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd32), .done(remainder_done[16]), .rem0(rem0[16]));
	remainder_test test17(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd34), .done(remainder_done[17]), .rem0(rem0[17]));
	remainder_test test18(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd36), .done(remainder_done[18]), .rem0(rem0[18]));
	remainder_test test19(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd38), .done(remainder_done[19]), .rem0(rem0[19]));
	remainder_test test20(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd40), .done(remainder_done[20]), .rem0(rem0[20]));
	remainder_test test21(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd42), .done(remainder_done[21]), .rem0(rem0[21]));
	remainder_test test22(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd44), .done(remainder_done[22]), .rem0(rem0[22]));
	remainder_test test23(.clk(clk), .rst((rst | clear)), .numerator(dividend), .denominator(count[63:0] + 6'd46), .done(remainder_done[23]), .rem0(rem0[23]));
	
	
	reg [3:0] state;
	reg [3:0] state_c;
	
	
	
	//State Definitions
	parameter INITIAL = 4'b0000;
	parameter REM_RESET_HIGH = 4'b0001;
	parameter REM_RESET_LOW = 4'b0010;
	parameter PROCESS = 4'b0011;
	parameter DONE = 4'b0100;
	
	
	//Algorithm
	always @(*) begin
	
		//Defaults
		count_c = count; //Number to divide by. Hold value
		is_prime_c = is_prime;
		done_c = done;
		state_c = state;
		remainder = remainder_c; //Fix output
		
		
		
		case (state)
			INITIAL: begin
				//reset at falling edge of start
				state_c = INITIAL;
				if (falling_transition == 1'b1) begin
					count_c = startValConcat; //Reset D to starting value
					done_c = 1'b0; //Not done with algorithm
					is_prime_c = 1'b1; //Defaults to prime unless proven otherwise
					//state_c = REM_RESET_HIGH;
					state_c = PROCESS;
					
					//Check if count is even. If so, make it odd by increasing it by one
					if (count_c[0] == 65'b0) begin
						count_c = count_c + 65'b1; 
					end
					
				end
				
				clear = 1'b1;
			end

			PROCESS: begin
				clear = 1'b0;
				//Check if even number
				
				if (dividend[0] == 1'b0 & (dividend != 64'd2)) begin
					is_prime_c = 1'b0;
					done_c = 1'b1;
					state_c = INITIAL;
				end
				
				if (remainder_done == 24'b111111111111111111111111) begin //If remainder has finished running
			
					//Check whether the remainder is equal to 0
					
					if (rem0 != 24'b000000000000000000000000) begin
						is_prime_c = 1'b0; //Not a prime number if evenly divisible by anything
						done_c = 1'b1;
						state_c = INITIAL;
					end
					
					count_c = count + 65'd48; //Increment by 24 since there are 24 remainder testers
					
					//Reset remainder checker
					state_c = PROCESS;
					
					if ((count) > (endValConcat)) begin
						done_c = 1'b1;
						state_c = INITIAL;
					end
				end
				
				
			end
			DONE: begin
				
			end
		endcase
			
		//Reset
		if(rst == 1'b1) begin
			state_c = INITIAL;
			count_c = startValConcat; //Reset D to 2
			done_c = 1'b0; //Not done with algorithm
			is_prime_c = 1'b1; //Defaults to prime unless proven otherwise
		end
		
	end
	
	//FFs
	always @(posedge clk) begin
		count <= #1 count_c;
		is_prime <= #1 is_prime_c; 
		done <= #1 done_c;
		state <= #1 state_c;
		//remainder <= #1 remainder_c;
	end
	
endmodule

//Finds the remainder of a number. Only needs to check odd/odd
module remainder_test(clk, rst, numerator, denominator, done, rem0);
	
	input clk, rst;
	input [63:0] numerator, denominator;
	reg [63:0] remainder;
	output reg done, rem0;
	reg done_c, rem0_c;
	
	reg [5:0] i;
	reg [5:0] i_c;
	reg [63:0] remainder_c;
	
	reg [63:0] Ni;
	
	always @(*) begin
		done_c = done;
		rem0_c = rem0;
		
		i_c = i - 6'b000001; //Subtract one
		
		remainder_c = remainder << 1'b1;
		Ni = numerator << (6'b111111 - i);
		remainder_c[0] = Ni[63];
		if (remainder_c >= denominator) begin
			remainder_c = remainder_c - denominator;
		end
		
		//Check if odd numerator and even denominator
		if(numerator[0] == 1'b1 & denominator[0] == 1'b0) begin
			done_c = 1'b1;
			remainder_c = 2'b11;
			rem0_c = 1'b0; //Placeholder, anything will work as long as its not 0
		end
		
		if (numerator <= denominator) begin
			done_c = 1'b1;
			remainder_c = 2'b11;
			rem0_c = 1'b0;
		end
		
		//Ignore Divide by 0 or 1
		if (denominator == 64'b0 | denominator == 64'b1) begin
			done_c = 1'b1;
			remainder_c = 2'b11;
			rem0_c = 1'b0;
		end
		
		//Return value
		if (i == 6'b000000) begin //Return value, reset
			done_c = 1'b1; //End
			
			if(remainder_c == 64'b0) begin //If the remainder is equal to zero
				rem0_c = 1'b1;
			end
			
		end
		else begin
			done_c = 1'b0;
		end
	
	
		if (rst == 1'b1 | done == 1'b1) begin //If reset or done
			i_c = 6'b111111;
			remainder_c = 64'b0;
			done_c = 1'b0;
			rem0_c = 1'b0;
		end
	end
	
	
	always @(posedge clk) begin
		i <= #1 i_c; //Counter
		remainder <= #1 remainder_c;
		done <= #1 done_c;
		rem0 <= #1 rem0_c;
	end
	
endmodule

module number_generator(clk, rst, sample, debug, value);
	input clk, rst, sample; //Connected to KEY0. Tells whether to generate a value
	input [1:0] debug;
	output reg [63:0] value;
	
	reg [31:0] count, count_c;
	reg [63:0] value_c;
	wire rising_transition, falling_transition;
	
	//Instantiate edge detector modules
	edge_detector_rising edge_detector_rising1(.clk(clk), .input_signal(sample), .rising_transition(rising_transition));
	edge_detector_falling edge_detector_falling1(.clk(clk), .input_signal(sample), .falling_transition(falling_transition));
		
	//Counter
	always @(*) begin
		//Default
		count_c = count + 32'b0000000000000001; //Add 1
		value_c = value;
		
		case (debug)
			2'b00: begin //Generate random number
				if (falling_transition == 1'b1) begin
					value_c = {value[63:32], count};
				end
				if(rising_transition == 1'b1) begin
					value_c = {count, value[31:0]};
				end
			end
			2'b01: begin //Constant 64-bit non prime number
				value_c = 64'd4294967315;
			end
			2'b10: begin //Constant 64-bit prime number
				value_c = 64'd130680497;
			end
			2'b11: begin //Large 64-bit prime number
				//value_c = 64'd2147483659;
				value_c = 64'd4294967311;
			end
			
		endcase
		
		//Reset
		if (rst == 1'b1) begin
			count_c = 32'b0000000000000000; //Reset
			value_c = 64'b0;
		end
		
	end
	
	//FFs
	always @(*) begin
		count <= #1 count_c;
		value <= #1 value_c;
	end
	
endmodule

//Detects whether there is a rising signal.
module edge_detector_rising(clk, input_signal, rising_transition);
	
	input clk, input_signal;
	output reg rising_transition;
	
	reg n;
	wire rising_transition_c;
	
	assign rising_transition_c = ~n & input_signal;
	
	always @(posedge clk) begin
		n <= #1 input_signal;
		rising_transition <= rising_transition_c;
	end
	
endmodule

//Detects whether there is a falling signal.
module edge_detector_falling(clk, input_signal, falling_transition);
	
	input clk, input_signal;
	output reg falling_transition;
	
	reg n;
	wire falling_transition_c;
	
	assign falling_transition_c = n & ~input_signal;
	
	always @(posedge clk) begin
		n <= #1 input_signal;
		falling_transition <= falling_transition_c;
	end
	
endmodule
